/* SPDX-License-Identifier: BSD-2-Clause */
//[File]            : ssusb_epctl_csr.h
//[Revision time]   : Wed Sep 15 22:23:12 2021
//[Description]     : This file is auto generated by CODA
//[Copyright]       : Copyright (C) 2021 Mediatek Incorportion. All rights reserved.

#ifndef __SSUSB_EPCTL_CSR_REGS_H__
#define __SSUSB_EPCTL_CSR_REGS_H__

#include "hal_common.h"

#ifdef __cplusplus
extern "C" {
#endif


//****************************************************************************
//
//                     SSUSB_EPCTL_CSR CR Definitions                     
//
//****************************************************************************

#define SSUSB_EPCTL_CSR_BASE                                   0x74011800

#define SSUSB_EPCTL_CSR_DEVICE_CONF_ADDR                       (SSUSB_EPCTL_CSR_BASE + 0x000) // 1800
#define SSUSB_EPCTL_CSR_EP_RST_ADDR                            (SSUSB_EPCTL_CSR_BASE + 0x004) // 1804
#define SSUSB_EPCTL_CSR_USB3_ERDY_TIMING_PARAMETER_ADDR        (SSUSB_EPCTL_CSR_BASE + 0x008) // 1808
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ADDR                   (SSUSB_EPCTL_CSR_BASE + 0x00c) // 180C
#define SSUSB_EPCTL_CSR_USB2_ISOINEP_INCOMP_INTR_ADDR          (SSUSB_EPCTL_CSR_BASE + 0x010) // 1810
#define SSUSB_EPCTL_CSR_USB2_ISOOUTEP_INCOMP_ERR_ADDR          (SSUSB_EPCTL_CSR_BASE + 0x014) // 1814
#define SSUSB_EPCTL_CSR_ISO_UNDERRUN_INTR_ADDR                 (SSUSB_EPCTL_CSR_BASE + 0x018) // 1818
#define SSUSB_EPCTL_CSR_ISO_OVERRUN_INTR_ADDR                  (SSUSB_EPCTL_CSR_BASE + 0x01c) // 181C
#define SSUSB_EPCTL_CSR_USB2_RX_EP_DATAERR_INTR_ADDR           (SSUSB_EPCTL_CSR_BASE + 0x020) // 1820
#define SSUSB_EPCTL_CSR_USB2_EPCTRL_CAP_ADDR                   (SSUSB_EPCTL_CSR_BASE + 0x024) // 1824
#define SSUSB_EPCTL_CSR_USB2_EPCTL_LPM_ADDR                    (SSUSB_EPCTL_CSR_BASE + 0x028) // 1828
#define SSUSB_EPCTL_CSR_USB3_SW_ERDY_ADDR                      (SSUSB_EPCTL_CSR_BASE + 0x030) // 1830
#define SSUSB_EPCTL_CSR_EP_FLOW_CTRL_ADDR                      (SSUSB_EPCTL_CSR_BASE + 0x040) // 1840
#define SSUSB_EPCTL_CSR_USB3_EP_ACT_ADDR                       (SSUSB_EPCTL_CSR_BASE + 0x044) // 1844
#define SSUSB_EPCTL_CSR_USB3_EP_PACKET_PENDING_ADDR            (SSUSB_EPCTL_CSR_BASE + 0x048) // 1848
#define SSUSB_EPCTL_CSR_DEV_LINK_INTR_ENABLE_ADDR              (SSUSB_EPCTL_CSR_BASE + 0x050) // 1850
#define SSUSB_EPCTL_CSR_DEV_LINK_INTR_ADDR                     (SSUSB_EPCTL_CSR_BASE + 0x054) // 1854
#define SSUSB_EPCTL_CSR_USB2_EPCTL_LPM_FC_CHK_ADDR             (SSUSB_EPCTL_CSR_BASE + 0x060) // 1860
#define SSUSB_EPCTL_CSR_DEVICE_MONITOR_ADDR                    (SSUSB_EPCTL_CSR_BASE + 0x064) // 1864
#define SSUSB_EPCTL_CSR_USB2_ISOINEP_INCOMP_INTR_MD_ADDR       (SSUSB_EPCTL_CSR_BASE + 0x070) // 1870
#define SSUSB_EPCTL_CSR_USB2_ISOOUTEP_INCOMP_ERR_MD_ADDR       (SSUSB_EPCTL_CSR_BASE + 0x074) // 1874
#define SSUSB_EPCTL_CSR_ISO_UNDERRUN_INTR_MD_ADDR              (SSUSB_EPCTL_CSR_BASE + 0x078) // 1878
#define SSUSB_EPCTL_CSR_ISO_OVERRUN_INTR_MD_ADDR               (SSUSB_EPCTL_CSR_BASE + 0x07c) // 187C
#define SSUSB_EPCTL_CSR_USB2_RX_EP_DATAERR_INTR_MD_ADDR        (SSUSB_EPCTL_CSR_BASE + 0x080) // 1880
#define SSUSB_EPCTL_CSR_EP_RST_OPT_ADDR                        (SSUSB_EPCTL_CSR_BASE + 0x090) // 1890




/* =====================================================================================

  ---DEVICE_CONF (0x74011800 + 0x000)---

    ssusb_dev_speed[2..0]        - (RO) Indicate device operated link and speed.
                                     3'b000 : Inactive.
                                     3'b001 : FS
                                     3'b011 : HS
                                     3'b100 : SS Gen1
                                     3'b101 : SS Gen2
                                     other : Reserved;
    RESERVED3[15..3]             - (RO) Reserved bits
    sw_usb2_3_sel[16]            - (RW) SW decide usb3 or usb2 => the register will select PNPI data path for USB3 or USB2 by SW.
                                     0 : USB2
                                     1 : USB3
    sw_usb2_3_sel_en[17]         - (RW) Enable the sw_usb2_3_sel.
                                     USB2 or USB3 data path is decided by SW.
                                     0 : Data path select is decided by HW.
                                     1 : Data path select is decided by SW.
    hw_usb2_3_sel[18]            - (RO) Result of USB2/USB3  data path selection by HW.
                                     0 : USB2
                                     1 : USB3
    RESERVED19[23..19]           - (RO) Reserved bits
    dev_addr[30..24]             - (RW) Device only.
                                     Software should set device address register when receiving set addr command
    RESERVED31[31]               - (RO) Reserved bits

 =====================================================================================*/
#define SSUSB_EPCTL_CSR_DEVICE_CONF_dev_addr_ADDR              SSUSB_EPCTL_CSR_DEVICE_CONF_ADDR
#define SSUSB_EPCTL_CSR_DEVICE_CONF_dev_addr_MASK              0x7F000000                // dev_addr[30..24]
#define SSUSB_EPCTL_CSR_DEVICE_CONF_dev_addr_SHFT              24
#define SSUSB_EPCTL_CSR_DEVICE_CONF_hw_usb2_3_sel_ADDR         SSUSB_EPCTL_CSR_DEVICE_CONF_ADDR
#define SSUSB_EPCTL_CSR_DEVICE_CONF_hw_usb2_3_sel_MASK         0x00040000                // hw_usb2_3_sel[18]
#define SSUSB_EPCTL_CSR_DEVICE_CONF_hw_usb2_3_sel_SHFT         18
#define SSUSB_EPCTL_CSR_DEVICE_CONF_sw_usb2_3_sel_en_ADDR      SSUSB_EPCTL_CSR_DEVICE_CONF_ADDR
#define SSUSB_EPCTL_CSR_DEVICE_CONF_sw_usb2_3_sel_en_MASK      0x00020000                // sw_usb2_3_sel_en[17]
#define SSUSB_EPCTL_CSR_DEVICE_CONF_sw_usb2_3_sel_en_SHFT      17
#define SSUSB_EPCTL_CSR_DEVICE_CONF_sw_usb2_3_sel_ADDR         SSUSB_EPCTL_CSR_DEVICE_CONF_ADDR
#define SSUSB_EPCTL_CSR_DEVICE_CONF_sw_usb2_3_sel_MASK         0x00010000                // sw_usb2_3_sel[16]
#define SSUSB_EPCTL_CSR_DEVICE_CONF_sw_usb2_3_sel_SHFT         16
#define SSUSB_EPCTL_CSR_DEVICE_CONF_ssusb_dev_speed_ADDR       SSUSB_EPCTL_CSR_DEVICE_CONF_ADDR
#define SSUSB_EPCTL_CSR_DEVICE_CONF_ssusb_dev_speed_MASK       0x00000007                // ssusb_dev_speed[2..0]
#define SSUSB_EPCTL_CSR_DEVICE_CONF_ssusb_dev_speed_SHFT       0

/* =====================================================================================

  ---EP_RST (0x74011800 + 0x004)---

    ep0_rst[0]                   - (RW) endpoint 0  reset
                                     
                                     the reset will reset :
                                     USB20 : data toggle
                                     SSUSB : sequence number, flow control status, packet pending status, ep active status, ep packet counter
    ep_out_rst[15..1]            - (RW) endpoint out 1 ~ 15 reset
                                     bit 1 : ep1 out
                                     bit 2 : ep2 out
                                     .
                                     Bit 15 : ep15 out
                                     
                                     the reset will reset :
                                     USB20 : data toggle
                                     SSUSB : sequence number, flow control status, packet pending status, ep active status, ep packet counter
    RESERVED16[16]               - (RO) Reserved bits
    ep_in_rst[31..17]            - (RW) endpoint in 1 ~ 15 reset
                                     bit 17 : ep1 in
                                     bit 18 : ep2 in
                                     .
                                     Bit 31 : ep15 in
                                     
                                     the reset will reset :
                                     USB20 : data toggle
                                     SSUSB :  sequence number, flow control status, packet pending status, ep active status, ep packet counter

 =====================================================================================*/
#define SSUSB_EPCTL_CSR_EP_RST_ep_in_rst_ADDR                  SSUSB_EPCTL_CSR_EP_RST_ADDR
#define SSUSB_EPCTL_CSR_EP_RST_ep_in_rst_MASK                  0xFFFE0000                // ep_in_rst[31..17]
#define SSUSB_EPCTL_CSR_EP_RST_ep_in_rst_SHFT                  17
#define SSUSB_EPCTL_CSR_EP_RST_ep_out_rst_ADDR                 SSUSB_EPCTL_CSR_EP_RST_ADDR
#define SSUSB_EPCTL_CSR_EP_RST_ep_out_rst_MASK                 0x0000FFFE                // ep_out_rst[15..1]
#define SSUSB_EPCTL_CSR_EP_RST_ep_out_rst_SHFT                 1
#define SSUSB_EPCTL_CSR_EP_RST_ep0_rst_ADDR                    SSUSB_EPCTL_CSR_EP_RST_ADDR
#define SSUSB_EPCTL_CSR_EP_RST_ep0_rst_MASK                    0x00000001                // ep0_rst[0]
#define SSUSB_EPCTL_CSR_EP_RST_ep0_rst_SHFT                    0

/* =====================================================================================

  ---USB3_ERDY_TIMING_PARAMETER (0x74011800 + 0x008)---

    erdy_timeout_value[9..0]     - (RW) Timeout value after a device sends an ERDY to host.
                                     After sending ERDY, Device can't initiate or accept a U1 or U2 request if device is not serviced. 
                                     Device only can initial or request U1 or U2 request after timeout or host has serviced device after ERDY. 
                                     (USB3 SPEC : tERDYTimeout).
                                     
                                     For speed up simulation time, SW can set "sys_speed_ms_to_us" in "mac_usb3_sys_port" CSR to change unit 1ms to unit 1us.
                                     UNIT : 1ms (default is 500ms)
    RESERVED10[31..10]           - (RO) Reserved bits

 =====================================================================================*/
#define SSUSB_EPCTL_CSR_USB3_ERDY_TIMING_PARAMETER_erdy_timeout_value_ADDR SSUSB_EPCTL_CSR_USB3_ERDY_TIMING_PARAMETER_ADDR
#define SSUSB_EPCTL_CSR_USB3_ERDY_TIMING_PARAMETER_erdy_timeout_value_MASK 0x000003FF                // erdy_timeout_value[9..0]
#define SSUSB_EPCTL_CSR_USB3_ERDY_TIMING_PARAMETER_erdy_timeout_value_SHFT 0

/* =====================================================================================

  ---USB3_EPCTRL_CAP (0x74011800 + 0x00c)---

    tx_burst_en[0]               - (RW) Enable burst capability for IN endpoint
    set_eob_en[1]                - (RW) 0 : hardware don't set EOB in the last data packet header
                                     1 : hardware set EOB in the last data packet header
    usb3_iso_crc_chk_dis[2]      - (RW) 0: enable usb3 epctrl iso out CRC check.
                                     1: disable usb3 epctrl iso out CRC check.
    send_stall_clr_pp_en[3]      - (RW) 0 : send stall will clear endpoint packet pending flag.
                                     1 : send stall won't clear endpoint packet pending flag
    tx_nump_0_en[4]              - (RW) 0 : send ack with nump = 1 even if rx buffer is full (exclude setup and status packet)
                                     1 : send ack with nump = 0 when rx buffer is full.
    tx_nump_cfg_en[5]            - (RW) 0 : NumP value is not configurable 
                                     1:  NumP value is configurable to tx_nump_cfg_value
    tx_nump_cfg_value[10..6]     - (RW) If tx_nump_cfg_en=1, always set NumP=tx_nump_cfg_value in ACK TP, responding to NISO DP @ OUT transfer
    tx_burst_wait_en[11]         - (RW) 0: when buffer is inavailable, stop TX no more packet even buffer is available again. Restart TX packet till all ACK are received
                                     1: when buffer is inavailable, stop TX packet. Restart TX packet when buffer is available again.
    u3_in_bug_fix_bypass[12]     - (RW) 0 : use bug fix HW for IN retry
                                     1 : bypass bug fix HW for IN retry
    RESERVED13[15..13]           - (RO) Reserved bits
    dp_more_mps_discard_en[16]   - (RW) If Data payload length is more than Max Packet Size, EPCtrl will discard the data packet.
                                     0 : Disable.
                                     1 : Enable.
    chk_tt_dis[17]               - (RW) For Gen2
                                     If EPCtrl check TT for received Header.
                                     0 : Disable.
                                     1 : Enable.
    deferred_chk_tt_dis[18]      - (RW) For Gen2
                                     If EPCtrl check TT for received Deferred Header.
                                     0 : Disable.
                                     1 : Enable.
    iso_ser_int_upd_sel[19]      - (RW) if Design will detect iso service interval by ITP frame number and clear sequence number.
                                     0 : disable
                                     1 : enable
    ep_in_rst_after_stall_en[20] - (RW) If HW will auto reset epN IN logic of epctl & bmu after sent stall.
                                     0: Disable
                                     1: Enable
    ep_out_rst_after_stall_en[21] - (RW) If HW will auto reset epN OUT logic of epctl & bmu after sent stall.
                                     0: Disable
                                     1: Enable
    ep0_rst_after_stall_en[22]   - (RW) If HW will auto reset ep0 logic of epctl & bmu after sent stall.
                                     0: Disable
                                     1: Enable
    ep0_setup_stop_by_reject_en[23] - (RW) Consider whether to STOP SETUP DP in case of reject (e.g. In flow control condition).
                                     1'b1: SETUP DP would be rejected once the reject condition exists.
                                     1'b0: SETUP DP would never be rejected.  Device can always latch 8 byte valid SETUP DPP.
    RESERVED24[31..24]           - (RO) Reserved bits

 =====================================================================================*/
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ep0_setup_stop_by_reject_en_ADDR SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ADDR
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ep0_setup_stop_by_reject_en_MASK 0x00800000                // ep0_setup_stop_by_reject_en[23]
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ep0_setup_stop_by_reject_en_SHFT 23
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ep0_rst_after_stall_en_ADDR SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ADDR
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ep0_rst_after_stall_en_MASK 0x00400000                // ep0_rst_after_stall_en[22]
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ep0_rst_after_stall_en_SHFT 22
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ep_out_rst_after_stall_en_ADDR SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ADDR
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ep_out_rst_after_stall_en_MASK 0x00200000                // ep_out_rst_after_stall_en[21]
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ep_out_rst_after_stall_en_SHFT 21
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ep_in_rst_after_stall_en_ADDR SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ADDR
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ep_in_rst_after_stall_en_MASK 0x00100000                // ep_in_rst_after_stall_en[20]
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ep_in_rst_after_stall_en_SHFT 20
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_iso_ser_int_upd_sel_ADDR SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ADDR
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_iso_ser_int_upd_sel_MASK 0x00080000                // iso_ser_int_upd_sel[19]
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_iso_ser_int_upd_sel_SHFT 19
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_deferred_chk_tt_dis_ADDR SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ADDR
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_deferred_chk_tt_dis_MASK 0x00040000                // deferred_chk_tt_dis[18]
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_deferred_chk_tt_dis_SHFT 18
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_chk_tt_dis_ADDR        SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ADDR
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_chk_tt_dis_MASK        0x00020000                // chk_tt_dis[17]
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_chk_tt_dis_SHFT        17
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_dp_more_mps_discard_en_ADDR SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ADDR
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_dp_more_mps_discard_en_MASK 0x00010000                // dp_more_mps_discard_en[16]
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_dp_more_mps_discard_en_SHFT 16
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_u3_in_bug_fix_bypass_ADDR SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ADDR
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_u3_in_bug_fix_bypass_MASK 0x00001000                // u3_in_bug_fix_bypass[12]
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_u3_in_bug_fix_bypass_SHFT 12
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_tx_burst_wait_en_ADDR  SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ADDR
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_tx_burst_wait_en_MASK  0x00000800                // tx_burst_wait_en[11]
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_tx_burst_wait_en_SHFT  11
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_tx_nump_cfg_value_ADDR SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ADDR
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_tx_nump_cfg_value_MASK 0x000007C0                // tx_nump_cfg_value[10..6]
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_tx_nump_cfg_value_SHFT 6
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_tx_nump_cfg_en_ADDR    SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ADDR
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_tx_nump_cfg_en_MASK    0x00000020                // tx_nump_cfg_en[5]
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_tx_nump_cfg_en_SHFT    5
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_tx_nump_0_en_ADDR      SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ADDR
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_tx_nump_0_en_MASK      0x00000010                // tx_nump_0_en[4]
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_tx_nump_0_en_SHFT      4
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_send_stall_clr_pp_en_ADDR SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ADDR
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_send_stall_clr_pp_en_MASK 0x00000008                // send_stall_clr_pp_en[3]
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_send_stall_clr_pp_en_SHFT 3
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_usb3_iso_crc_chk_dis_ADDR SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ADDR
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_usb3_iso_crc_chk_dis_MASK 0x00000004                // usb3_iso_crc_chk_dis[2]
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_usb3_iso_crc_chk_dis_SHFT 2
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_set_eob_en_ADDR        SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ADDR
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_set_eob_en_MASK        0x00000002                // set_eob_en[1]
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_set_eob_en_SHFT        1
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_tx_burst_en_ADDR       SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_ADDR
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_tx_burst_en_MASK       0x00000001                // tx_burst_en[0]
#define SSUSB_EPCTL_CSR_USB3_EPCTRL_CAP_tx_burst_en_SHFT       0

/* =====================================================================================

  ---USB2_ISOINEP_INCOMP_INTR (0x74011800 + 0x010)---

    RESERVED0[0]                 - (RO) Reserved bits
    usb2_isoinep_incomp_intr_val[15..1] - (W1C) When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received.
    RESERVED16[16]               - (RO) Reserved bits
    usb2_isoinep_incomp_intr_en[31..17] - (RW) Writing 1 to this register, the corresponding ISO IN incompleted indication generated from U2_EPCTL should be Enabled.
                                     0 : disable
                                     1 : enable iso in incomplete interrupt

 =====================================================================================*/
#define SSUSB_EPCTL_CSR_USB2_ISOINEP_INCOMP_INTR_usb2_isoinep_incomp_intr_en_ADDR SSUSB_EPCTL_CSR_USB2_ISOINEP_INCOMP_INTR_ADDR
#define SSUSB_EPCTL_CSR_USB2_ISOINEP_INCOMP_INTR_usb2_isoinep_incomp_intr_en_MASK 0xFFFE0000                // usb2_isoinep_incomp_intr_en[31..17]
#define SSUSB_EPCTL_CSR_USB2_ISOINEP_INCOMP_INTR_usb2_isoinep_incomp_intr_en_SHFT 17
#define SSUSB_EPCTL_CSR_USB2_ISOINEP_INCOMP_INTR_usb2_isoinep_incomp_intr_val_ADDR SSUSB_EPCTL_CSR_USB2_ISOINEP_INCOMP_INTR_ADDR
#define SSUSB_EPCTL_CSR_USB2_ISOINEP_INCOMP_INTR_usb2_isoinep_incomp_intr_val_MASK 0x0000FFFE                // usb2_isoinep_incomp_intr_val[15..1]
#define SSUSB_EPCTL_CSR_USB2_ISOINEP_INCOMP_INTR_usb2_isoinep_incomp_intr_val_SHFT 1

/* =====================================================================================

  ---USB2_ISOOUTEP_INCOMP_ERR (0x74011800 + 0x014)---

    RESERVED0[0]                 - (RO) Reserved bits
    usb2_isooutep_incomp_intr[15..1] - (W1C) When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient OUT tokens have been received.
    RESERVED16[16]               - (RO) Reserved bits
    usb2_isooutep_incomp_intr_en[31..17] - (RW) Writing 1 to this register, the corresponding ISO OUT incompleted indication generated from U2_EPCTL should be Enabled.
                                     0 : disable
                                     1 : enable iso out incomplete interrupt

 =====================================================================================*/
#define SSUSB_EPCTL_CSR_USB2_ISOOUTEP_INCOMP_ERR_usb2_isooutep_incomp_intr_en_ADDR SSUSB_EPCTL_CSR_USB2_ISOOUTEP_INCOMP_ERR_ADDR
#define SSUSB_EPCTL_CSR_USB2_ISOOUTEP_INCOMP_ERR_usb2_isooutep_incomp_intr_en_MASK 0xFFFE0000                // usb2_isooutep_incomp_intr_en[31..17]
#define SSUSB_EPCTL_CSR_USB2_ISOOUTEP_INCOMP_ERR_usb2_isooutep_incomp_intr_en_SHFT 17
#define SSUSB_EPCTL_CSR_USB2_ISOOUTEP_INCOMP_ERR_usb2_isooutep_incomp_intr_ADDR SSUSB_EPCTL_CSR_USB2_ISOOUTEP_INCOMP_ERR_ADDR
#define SSUSB_EPCTL_CSR_USB2_ISOOUTEP_INCOMP_ERR_usb2_isooutep_incomp_intr_MASK 0x0000FFFE                // usb2_isooutep_incomp_intr[15..1]
#define SSUSB_EPCTL_CSR_USB2_ISOOUTEP_INCOMP_ERR_usb2_isooutep_incomp_intr_SHFT 1

/* =====================================================================================

  ---ISO_UNDERRUN_INTR (0x74011800 + 0x018)---

    RESERVED0[0]                 - (RO) Reserved bits
    isoin_underrun_intr[15..1]   - (W1C) USB2/USB3 ISO endpoint IN underrun interrupt
                                     The interrupt can be used in USB2 or USB3
    RESERVED16[16]               - (RO) Reserved bits
    isoin_underrun_intr_en[31..17] - (RW) Writing 1 to this register, the corresponding ISO under run interrupt indication generated from SSUSB EPCTL should be Enabled.

 =====================================================================================*/
#define SSUSB_EPCTL_CSR_ISO_UNDERRUN_INTR_isoin_underrun_intr_en_ADDR SSUSB_EPCTL_CSR_ISO_UNDERRUN_INTR_ADDR
#define SSUSB_EPCTL_CSR_ISO_UNDERRUN_INTR_isoin_underrun_intr_en_MASK 0xFFFE0000                // isoin_underrun_intr_en[31..17]
#define SSUSB_EPCTL_CSR_ISO_UNDERRUN_INTR_isoin_underrun_intr_en_SHFT 17
#define SSUSB_EPCTL_CSR_ISO_UNDERRUN_INTR_isoin_underrun_intr_ADDR SSUSB_EPCTL_CSR_ISO_UNDERRUN_INTR_ADDR
#define SSUSB_EPCTL_CSR_ISO_UNDERRUN_INTR_isoin_underrun_intr_MASK 0x0000FFFE                // isoin_underrun_intr[15..1]
#define SSUSB_EPCTL_CSR_ISO_UNDERRUN_INTR_isoin_underrun_intr_SHFT 1

/* =====================================================================================

  ---ISO_OVERRUN_INTR (0x74011800 + 0x01c)---

    RESERVED0[0]                 - (RO) Reserved bits
    isoout_overrun_intr[15..1]   - (W1C) USB2/USB3 ISO endpoint OUT overrun interrupt.
                                     The interrupt can be used in USB2 or USB3
    RESERVED16[16]               - (RO) Reserved bits
    isoout_overrun_intr_en[31..17] - (RW) Writing 1 to this register, the corresponding ISO over run interrupt indication generated from SSUSB EPCTL should be Enabled.
                                     0 : disable
                                     1 : enable iso out overrun interrupt

 =====================================================================================*/
#define SSUSB_EPCTL_CSR_ISO_OVERRUN_INTR_isoout_overrun_intr_en_ADDR SSUSB_EPCTL_CSR_ISO_OVERRUN_INTR_ADDR
#define SSUSB_EPCTL_CSR_ISO_OVERRUN_INTR_isoout_overrun_intr_en_MASK 0xFFFE0000                // isoout_overrun_intr_en[31..17]
#define SSUSB_EPCTL_CSR_ISO_OVERRUN_INTR_isoout_overrun_intr_en_SHFT 17
#define SSUSB_EPCTL_CSR_ISO_OVERRUN_INTR_isoout_overrun_intr_ADDR SSUSB_EPCTL_CSR_ISO_OVERRUN_INTR_ADDR
#define SSUSB_EPCTL_CSR_ISO_OVERRUN_INTR_isoout_overrun_intr_MASK 0x0000FFFE                // isoout_overrun_intr[15..1]
#define SSUSB_EPCTL_CSR_ISO_OVERRUN_INTR_isoout_overrun_intr_SHFT 1

/* =====================================================================================

  ---USB2_RX_EP_DATAERR_INTR (0x74011800 + 0x020)---

    usb2_rx_ep_dataerr_intr_val[15..0] - (W1C) usb2 rx endpoint data error interrupt , include CRC error and Data Toggled error
    usb2_rx_ep_dataerr_intr_en[31..16] - (RW) Writing 1 to this register, the corresponding rx endpoint data error interrupt indication generated from U2_EPCTL should be Enabled.
                                     0 : disable
                                     1 : enable rx endpoint data error interrupt

 =====================================================================================*/
#define SSUSB_EPCTL_CSR_USB2_RX_EP_DATAERR_INTR_usb2_rx_ep_dataerr_intr_en_ADDR SSUSB_EPCTL_CSR_USB2_RX_EP_DATAERR_INTR_ADDR
#define SSUSB_EPCTL_CSR_USB2_RX_EP_DATAERR_INTR_usb2_rx_ep_dataerr_intr_en_MASK 0xFFFF0000                // usb2_rx_ep_dataerr_intr_en[31..16]
#define SSUSB_EPCTL_CSR_USB2_RX_EP_DATAERR_INTR_usb2_rx_ep_dataerr_intr_en_SHFT 16
#define SSUSB_EPCTL_CSR_USB2_RX_EP_DATAERR_INTR_usb2_rx_ep_dataerr_intr_val_ADDR SSUSB_EPCTL_CSR_USB2_RX_EP_DATAERR_INTR_ADDR
#define SSUSB_EPCTL_CSR_USB2_RX_EP_DATAERR_INTR_usb2_rx_ep_dataerr_intr_val_MASK 0x0000FFFF                // usb2_rx_ep_dataerr_intr_val[15..0]
#define SSUSB_EPCTL_CSR_USB2_RX_EP_DATAERR_INTR_usb2_rx_ep_dataerr_intr_val_SHFT 0

/* =====================================================================================

  ---USB2_EPCTRL_CAP (0x74011800 + 0x024)---

    usb2_iso_crc_chk_dis[0]      - (RW) 0: enable usb2 epctrl iso out CRC check.
                                     1 : disable usb2 epctrl iso out CRC check.
    RESERVED1[31..1]             - (RO) Reserved bits

 =====================================================================================*/
#define SSUSB_EPCTL_CSR_USB2_EPCTRL_CAP_usb2_iso_crc_chk_dis_ADDR SSUSB_EPCTL_CSR_USB2_EPCTRL_CAP_ADDR
#define SSUSB_EPCTL_CSR_USB2_EPCTRL_CAP_usb2_iso_crc_chk_dis_MASK 0x00000001                // usb2_iso_crc_chk_dis[0]
#define SSUSB_EPCTL_CSR_USB2_EPCTRL_CAP_usb2_iso_crc_chk_dis_SHFT 0

/* =====================================================================================

  ---USB2_EPCTL_LPM (0x74011800 + 0x028)---

    l1_exit_ep0_chk[0]           - (RW) EP0 LPM L1 exit check enable
    l1_exit_ep_in_chk[15..1]     - (RW) TXEP LPM L1 exit check enable
    RESERVED16[16]               - (RO) Reserved bits
    l1_exit_ep_out_chk[31..17]   - (RW) RXEP LPM L1 exit check enable

 =====================================================================================*/
#define SSUSB_EPCTL_CSR_USB2_EPCTL_LPM_l1_exit_ep_out_chk_ADDR SSUSB_EPCTL_CSR_USB2_EPCTL_LPM_ADDR
#define SSUSB_EPCTL_CSR_USB2_EPCTL_LPM_l1_exit_ep_out_chk_MASK 0xFFFE0000                // l1_exit_ep_out_chk[31..17]
#define SSUSB_EPCTL_CSR_USB2_EPCTL_LPM_l1_exit_ep_out_chk_SHFT 17
#define SSUSB_EPCTL_CSR_USB2_EPCTL_LPM_l1_exit_ep_in_chk_ADDR  SSUSB_EPCTL_CSR_USB2_EPCTL_LPM_ADDR
#define SSUSB_EPCTL_CSR_USB2_EPCTL_LPM_l1_exit_ep_in_chk_MASK  0x0000FFFE                // l1_exit_ep_in_chk[15..1]
#define SSUSB_EPCTL_CSR_USB2_EPCTL_LPM_l1_exit_ep_in_chk_SHFT  1
#define SSUSB_EPCTL_CSR_USB2_EPCTL_LPM_l1_exit_ep0_chk_ADDR    SSUSB_EPCTL_CSR_USB2_EPCTL_LPM_ADDR
#define SSUSB_EPCTL_CSR_USB2_EPCTL_LPM_l1_exit_ep0_chk_MASK    0x00000001                // l1_exit_ep0_chk[0]
#define SSUSB_EPCTL_CSR_USB2_EPCTL_LPM_l1_exit_ep0_chk_SHFT    0

/* =====================================================================================

  ---USB3_SW_ERDY (0x74011800 + 0x030)---

    sw_send_erdy[0]              - (RO) Software can set the register to request send ERDY.
                                     After ERDY is sent, HW will clear the register
    sw_erdy_ep_dir[1]            - (RW) Software must set the register before set sw_send_erdy.
                                     The register decide the SW ERDY endpoint direction.
                                     0 : OUTdirection
                                     1 : IN direction
                                     EP0 : must be 0
    sw_erdy_ep_num[5..2]         - (RW) Software must set the register before set sw_send_erdy.
                                     The register decide the SW ERDY endpoint number.
    RESERVED6[31..6]             - (RO) Reserved bits

 =====================================================================================*/
#define SSUSB_EPCTL_CSR_USB3_SW_ERDY_sw_erdy_ep_num_ADDR       SSUSB_EPCTL_CSR_USB3_SW_ERDY_ADDR
#define SSUSB_EPCTL_CSR_USB3_SW_ERDY_sw_erdy_ep_num_MASK       0x0000003C                // sw_erdy_ep_num[5..2]
#define SSUSB_EPCTL_CSR_USB3_SW_ERDY_sw_erdy_ep_num_SHFT       2
#define SSUSB_EPCTL_CSR_USB3_SW_ERDY_sw_erdy_ep_dir_ADDR       SSUSB_EPCTL_CSR_USB3_SW_ERDY_ADDR
#define SSUSB_EPCTL_CSR_USB3_SW_ERDY_sw_erdy_ep_dir_MASK       0x00000002                // sw_erdy_ep_dir[1]
#define SSUSB_EPCTL_CSR_USB3_SW_ERDY_sw_erdy_ep_dir_SHFT       1
#define SSUSB_EPCTL_CSR_USB3_SW_ERDY_sw_send_erdy_ADDR         SSUSB_EPCTL_CSR_USB3_SW_ERDY_ADDR
#define SSUSB_EPCTL_CSR_USB3_SW_ERDY_sw_send_erdy_MASK         0x00000001                // sw_send_erdy[0]
#define SSUSB_EPCTL_CSR_USB3_SW_ERDY_sw_send_erdy_SHFT         0

/* =====================================================================================

  ---EP_FLOW_CTRL (0x74011800 + 0x040)---

    ep_in_fc[15..0]              - (RO) Debug information.
                                     Check if IN endpoint is in flow control.
                                     Bit 0 : the in direction in EP0.
                                     Bit 1 : EP1
                                     Bit 15 : EP15
    ep_out_fc[31..16]            - (RO) Debug information.
                                     Check if OUT endpoint is in flow control.
                                     Bit 0 : the out direction in EP0.
                                     Bit 1 : EP1
                                     Bit 15 : EP15

 =====================================================================================*/
#define SSUSB_EPCTL_CSR_EP_FLOW_CTRL_ep_out_fc_ADDR            SSUSB_EPCTL_CSR_EP_FLOW_CTRL_ADDR
#define SSUSB_EPCTL_CSR_EP_FLOW_CTRL_ep_out_fc_MASK            0xFFFF0000                // ep_out_fc[31..16]
#define SSUSB_EPCTL_CSR_EP_FLOW_CTRL_ep_out_fc_SHFT            16
#define SSUSB_EPCTL_CSR_EP_FLOW_CTRL_ep_in_fc_ADDR             SSUSB_EPCTL_CSR_EP_FLOW_CTRL_ADDR
#define SSUSB_EPCTL_CSR_EP_FLOW_CTRL_ep_in_fc_MASK             0x0000FFFF                // ep_in_fc[15..0]
#define SSUSB_EPCTL_CSR_EP_FLOW_CTRL_ep_in_fc_SHFT             0

/* =====================================================================================

  ---USB3_EP_ACT (0x74011800 + 0x044)---

    ep_in_act[15..0]             - (RO) Debug information.
                                     Check if IN endpoint is active.
                                     Bit 0 : the in direction in EP0.
                                     Bit 1 : EP1
                                     Bit 15 : EP15
    RESERVED16[31..16]           - (RO) Reserved bits

 =====================================================================================*/
#define SSUSB_EPCTL_CSR_USB3_EP_ACT_ep_in_act_ADDR             SSUSB_EPCTL_CSR_USB3_EP_ACT_ADDR
#define SSUSB_EPCTL_CSR_USB3_EP_ACT_ep_in_act_MASK             0x0000FFFF                // ep_in_act[15..0]
#define SSUSB_EPCTL_CSR_USB3_EP_ACT_ep_in_act_SHFT             0

/* =====================================================================================

  ---USB3_EP_PACKET_PENDING (0x74011800 + 0x048)---

    ep_in_pp[15..0]              - (RO) Debug information.
                                     Check if IN endpoint has packet pending
                                     Bit 0 : the in direction in EP0.
                                     Bit 1 : EP1
                                     Bit 15 : EP15
    ep_out_pp[31..16]            - (RO) Debug information.
                                     Check if OUT endpoint has packet pending
                                     Bit 0 : the out direction in EP0.
                                     Bit 1 : EP1
                                     Bit 15 : EP15

 =====================================================================================*/
#define SSUSB_EPCTL_CSR_USB3_EP_PACKET_PENDING_ep_out_pp_ADDR  SSUSB_EPCTL_CSR_USB3_EP_PACKET_PENDING_ADDR
#define SSUSB_EPCTL_CSR_USB3_EP_PACKET_PENDING_ep_out_pp_MASK  0xFFFF0000                // ep_out_pp[31..16]
#define SSUSB_EPCTL_CSR_USB3_EP_PACKET_PENDING_ep_out_pp_SHFT  16
#define SSUSB_EPCTL_CSR_USB3_EP_PACKET_PENDING_ep_in_pp_ADDR   SSUSB_EPCTL_CSR_USB3_EP_PACKET_PENDING_ADDR
#define SSUSB_EPCTL_CSR_USB3_EP_PACKET_PENDING_ep_in_pp_MASK   0x0000FFFF                // ep_in_pp[15..0]
#define SSUSB_EPCTL_CSR_USB3_EP_PACKET_PENDING_ep_in_pp_SHFT   0

/* =====================================================================================

  ---DEV_LINK_INTR_ENABLE (0x74011800 + 0x050)---

    ssusb_dev_speed_chg_intr_en[0] - (RW) Enable the interrupt of "ssusb_dev_speed_chg_intr"
                                     0 : disable
                                     1 : enable
    ssusb_dev_speed_chg_intr_en_md[1] - (RW) Enable the interrupt of "ssusb_dev_speed_chg_intr" for MD
                                     0 : disable
                                     1 : enable
    RESERVED2[31..2]             - (RO) Reserved bits

 =====================================================================================*/
#define SSUSB_EPCTL_CSR_DEV_LINK_INTR_ENABLE_ssusb_dev_speed_chg_intr_en_md_ADDR SSUSB_EPCTL_CSR_DEV_LINK_INTR_ENABLE_ADDR
#define SSUSB_EPCTL_CSR_DEV_LINK_INTR_ENABLE_ssusb_dev_speed_chg_intr_en_md_MASK 0x00000002                // ssusb_dev_speed_chg_intr_en_md[1]
#define SSUSB_EPCTL_CSR_DEV_LINK_INTR_ENABLE_ssusb_dev_speed_chg_intr_en_md_SHFT 1
#define SSUSB_EPCTL_CSR_DEV_LINK_INTR_ENABLE_ssusb_dev_speed_chg_intr_en_ADDR SSUSB_EPCTL_CSR_DEV_LINK_INTR_ENABLE_ADDR
#define SSUSB_EPCTL_CSR_DEV_LINK_INTR_ENABLE_ssusb_dev_speed_chg_intr_en_MASK 0x00000001                // ssusb_dev_speed_chg_intr_en[0]
#define SSUSB_EPCTL_CSR_DEV_LINK_INTR_ENABLE_ssusb_dev_speed_chg_intr_en_SHFT 0

/* =====================================================================================

  ---DEV_LINK_INTR (0x74011800 + 0x054)---

    ssusb_dev_speed_chg_intr[0]  - (W1C) If ssusb device has any link and speed change event, the interrupt will be asserted.
                                     SW can read ssusb dev speed information in "ssusb_dev_speed" register.
    RESERVED1[31..1]             - (RO) Reserved bits

 =====================================================================================*/
#define SSUSB_EPCTL_CSR_DEV_LINK_INTR_ssusb_dev_speed_chg_intr_ADDR SSUSB_EPCTL_CSR_DEV_LINK_INTR_ADDR
#define SSUSB_EPCTL_CSR_DEV_LINK_INTR_ssusb_dev_speed_chg_intr_MASK 0x00000001                // ssusb_dev_speed_chg_intr[0]
#define SSUSB_EPCTL_CSR_DEV_LINK_INTR_ssusb_dev_speed_chg_intr_SHFT 0

/* =====================================================================================

  ---USB2_EPCTL_LPM_FC_CHK (0x74011800 + 0x060)---

    l1_exit_ep0_fc_chk[0]        - (RW) EP0 LPM L1 exit check flow control enable
    l1_exit_ep_in_fc_chk[15..1]  - (RW) TXEP LPM L1 exit check flow control enable
    RESERVED16[16]               - (RO) Reserved bits
    l1_exit_ep_out_fc_chk[31..17] - (RW) RXEP LPM L1 exit check flow control enable

 =====================================================================================*/
#define SSUSB_EPCTL_CSR_USB2_EPCTL_LPM_FC_CHK_l1_exit_ep_out_fc_chk_ADDR SSUSB_EPCTL_CSR_USB2_EPCTL_LPM_FC_CHK_ADDR
#define SSUSB_EPCTL_CSR_USB2_EPCTL_LPM_FC_CHK_l1_exit_ep_out_fc_chk_MASK 0xFFFE0000                // l1_exit_ep_out_fc_chk[31..17]
#define SSUSB_EPCTL_CSR_USB2_EPCTL_LPM_FC_CHK_l1_exit_ep_out_fc_chk_SHFT 17
#define SSUSB_EPCTL_CSR_USB2_EPCTL_LPM_FC_CHK_l1_exit_ep_in_fc_chk_ADDR SSUSB_EPCTL_CSR_USB2_EPCTL_LPM_FC_CHK_ADDR
#define SSUSB_EPCTL_CSR_USB2_EPCTL_LPM_FC_CHK_l1_exit_ep_in_fc_chk_MASK 0x0000FFFE                // l1_exit_ep_in_fc_chk[15..1]
#define SSUSB_EPCTL_CSR_USB2_EPCTL_LPM_FC_CHK_l1_exit_ep_in_fc_chk_SHFT 1
#define SSUSB_EPCTL_CSR_USB2_EPCTL_LPM_FC_CHK_l1_exit_ep0_fc_chk_ADDR SSUSB_EPCTL_CSR_USB2_EPCTL_LPM_FC_CHK_ADDR
#define SSUSB_EPCTL_CSR_USB2_EPCTL_LPM_FC_CHK_l1_exit_ep0_fc_chk_MASK 0x00000001                // l1_exit_ep0_fc_chk[0]
#define SSUSB_EPCTL_CSR_USB2_EPCTL_LPM_FC_CHK_l1_exit_ep0_fc_chk_SHFT 0

/* =====================================================================================

  ---DEVICE_MONITOR (0x74011800 + 0x064)---

    cur_dev_addr[6..0]           - (RO) Device only. Indicate device current device address
    RESERVED7[31..7]             - (RO) Reserved bits

 =====================================================================================*/
#define SSUSB_EPCTL_CSR_DEVICE_MONITOR_cur_dev_addr_ADDR       SSUSB_EPCTL_CSR_DEVICE_MONITOR_ADDR
#define SSUSB_EPCTL_CSR_DEVICE_MONITOR_cur_dev_addr_MASK       0x0000007F                // cur_dev_addr[6..0]
#define SSUSB_EPCTL_CSR_DEVICE_MONITOR_cur_dev_addr_SHFT       0

/* =====================================================================================

  ---USB2_ISOINEP_INCOMP_INTR_MD (0x74011800 + 0x070)---

    RESERVED0[0]                 - (RO) Reserved bits
    usb2_isoinep_incomp_intr_md[15..1] - (W1C) When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient IN tokens have been received.
    RESERVED16[16]               - (RO) Reserved bits
    usb2_isoinep_incomp_intr_en_md[31..17] - (RW) Writing 1 to this register, the corresponding ISO IN incompleted indication generated from U2_EPCTL should be Enabled.
                                     0 : disable
                                     1 : enable iso in incomplete interrupt

 =====================================================================================*/
#define SSUSB_EPCTL_CSR_USB2_ISOINEP_INCOMP_INTR_MD_usb2_isoinep_incomp_intr_en_md_ADDR SSUSB_EPCTL_CSR_USB2_ISOINEP_INCOMP_INTR_MD_ADDR
#define SSUSB_EPCTL_CSR_USB2_ISOINEP_INCOMP_INTR_MD_usb2_isoinep_incomp_intr_en_md_MASK 0xFFFE0000                // usb2_isoinep_incomp_intr_en_md[31..17]
#define SSUSB_EPCTL_CSR_USB2_ISOINEP_INCOMP_INTR_MD_usb2_isoinep_incomp_intr_en_md_SHFT 17
#define SSUSB_EPCTL_CSR_USB2_ISOINEP_INCOMP_INTR_MD_usb2_isoinep_incomp_intr_md_ADDR SSUSB_EPCTL_CSR_USB2_ISOINEP_INCOMP_INTR_MD_ADDR
#define SSUSB_EPCTL_CSR_USB2_ISOINEP_INCOMP_INTR_MD_usb2_isoinep_incomp_intr_md_MASK 0x0000FFFE                // usb2_isoinep_incomp_intr_md[15..1]
#define SSUSB_EPCTL_CSR_USB2_ISOINEP_INCOMP_INTR_MD_usb2_isoinep_incomp_intr_md_SHFT 1

/* =====================================================================================

  ---USB2_ISOOUTEP_INCOMP_ERR_MD (0x74011800 + 0x074)---

    RESERVED0[0]                 - (RO) Reserved bits
    usb2_isooutep_incomp_intr_md[15..1] - (W1C) When the endpoint is being used for high-bandwidth Isochronous/Interrupt transfers, this bit is set to indicate where a large packet has been split into 2 or 3 packets for transmission but insufficient OUT tokens have been received.
    RESERVED16[16]               - (RO) Reserved bits
    usb2_isooutep_incomp_intr_en_md[31..17] - (RW) Writing 1 to this register, the corresponding ISO OUT incompleted indication generated from U2_EPCTL should be Enabled.
                                     0 : disable
                                     1 : enable iso out incomplete interrupt

 =====================================================================================*/
#define SSUSB_EPCTL_CSR_USB2_ISOOUTEP_INCOMP_ERR_MD_usb2_isooutep_incomp_intr_en_md_ADDR SSUSB_EPCTL_CSR_USB2_ISOOUTEP_INCOMP_ERR_MD_ADDR
#define SSUSB_EPCTL_CSR_USB2_ISOOUTEP_INCOMP_ERR_MD_usb2_isooutep_incomp_intr_en_md_MASK 0xFFFE0000                // usb2_isooutep_incomp_intr_en_md[31..17]
#define SSUSB_EPCTL_CSR_USB2_ISOOUTEP_INCOMP_ERR_MD_usb2_isooutep_incomp_intr_en_md_SHFT 17
#define SSUSB_EPCTL_CSR_USB2_ISOOUTEP_INCOMP_ERR_MD_usb2_isooutep_incomp_intr_md_ADDR SSUSB_EPCTL_CSR_USB2_ISOOUTEP_INCOMP_ERR_MD_ADDR
#define SSUSB_EPCTL_CSR_USB2_ISOOUTEP_INCOMP_ERR_MD_usb2_isooutep_incomp_intr_md_MASK 0x0000FFFE                // usb2_isooutep_incomp_intr_md[15..1]
#define SSUSB_EPCTL_CSR_USB2_ISOOUTEP_INCOMP_ERR_MD_usb2_isooutep_incomp_intr_md_SHFT 1

/* =====================================================================================

  ---ISO_UNDERRUN_INTR_MD (0x74011800 + 0x078)---

    RESERVED0[0]                 - (RO) Reserved bits
    isoin_underrun_intr_md[15..1] - (W1C) USB2/USB3 ISO endpoint IN underrun interrupt
                                     The interrupt can be used in USB2 or USB3
    RESERVED16[16]               - (RO) Reserved bits
    isoin_underrun_intr_en_md[31..17] - (RW) Writing 1 to this register, the corresponding ISO under run interrupt indication generated from SSUSB EPCTL should be Enabled.

 =====================================================================================*/
#define SSUSB_EPCTL_CSR_ISO_UNDERRUN_INTR_MD_isoin_underrun_intr_en_md_ADDR SSUSB_EPCTL_CSR_ISO_UNDERRUN_INTR_MD_ADDR
#define SSUSB_EPCTL_CSR_ISO_UNDERRUN_INTR_MD_isoin_underrun_intr_en_md_MASK 0xFFFE0000                // isoin_underrun_intr_en_md[31..17]
#define SSUSB_EPCTL_CSR_ISO_UNDERRUN_INTR_MD_isoin_underrun_intr_en_md_SHFT 17
#define SSUSB_EPCTL_CSR_ISO_UNDERRUN_INTR_MD_isoin_underrun_intr_md_ADDR SSUSB_EPCTL_CSR_ISO_UNDERRUN_INTR_MD_ADDR
#define SSUSB_EPCTL_CSR_ISO_UNDERRUN_INTR_MD_isoin_underrun_intr_md_MASK 0x0000FFFE                // isoin_underrun_intr_md[15..1]
#define SSUSB_EPCTL_CSR_ISO_UNDERRUN_INTR_MD_isoin_underrun_intr_md_SHFT 1

/* =====================================================================================

  ---ISO_OVERRUN_INTR_MD (0x74011800 + 0x07c)---

    RESERVED0[0]                 - (RO) Reserved bits
    isoout_overrun_intr_md[15..1] - (W1C) USB2/USB3 ISO endpoint OUT overrun interrupt.
                                     The interrupt can be used in USB2 or USB3
    RESERVED16[16]               - (RO) Reserved bits
    isoout_overrun_intr_en_md[31..17] - (RW) Writing 1 to this register, the corresponding ISO over run interrupt indication generated from SSUSB EPCTL should be Enabled.
                                     0 : disable
                                     1 : enable iso out overrun interrupt

 =====================================================================================*/
#define SSUSB_EPCTL_CSR_ISO_OVERRUN_INTR_MD_isoout_overrun_intr_en_md_ADDR SSUSB_EPCTL_CSR_ISO_OVERRUN_INTR_MD_ADDR
#define SSUSB_EPCTL_CSR_ISO_OVERRUN_INTR_MD_isoout_overrun_intr_en_md_MASK 0xFFFE0000                // isoout_overrun_intr_en_md[31..17]
#define SSUSB_EPCTL_CSR_ISO_OVERRUN_INTR_MD_isoout_overrun_intr_en_md_SHFT 17
#define SSUSB_EPCTL_CSR_ISO_OVERRUN_INTR_MD_isoout_overrun_intr_md_ADDR SSUSB_EPCTL_CSR_ISO_OVERRUN_INTR_MD_ADDR
#define SSUSB_EPCTL_CSR_ISO_OVERRUN_INTR_MD_isoout_overrun_intr_md_MASK 0x0000FFFE                // isoout_overrun_intr_md[15..1]
#define SSUSB_EPCTL_CSR_ISO_OVERRUN_INTR_MD_isoout_overrun_intr_md_SHFT 1

/* =====================================================================================

  ---USB2_RX_EP_DATAERR_INTR_MD (0x74011800 + 0x080)---

    usb2_rx_ep_dataerr_intr_md[15..0] - (W1C) usb2 rx endpoint data error interrupt , include CRC error and Data Toggled error
    usb2_rx_ep_dataerr_intr_en_md[31..16] - (RW) Writing 1 to this register, the corresponding rx endpoint data error interrupt indication generated from U2_EPCTL should be Enabled.
                                     0 : disable
                                     1 : enable rx endpoint data error interrupt

 =====================================================================================*/
#define SSUSB_EPCTL_CSR_USB2_RX_EP_DATAERR_INTR_MD_usb2_rx_ep_dataerr_intr_en_md_ADDR SSUSB_EPCTL_CSR_USB2_RX_EP_DATAERR_INTR_MD_ADDR
#define SSUSB_EPCTL_CSR_USB2_RX_EP_DATAERR_INTR_MD_usb2_rx_ep_dataerr_intr_en_md_MASK 0xFFFF0000                // usb2_rx_ep_dataerr_intr_en_md[31..16]
#define SSUSB_EPCTL_CSR_USB2_RX_EP_DATAERR_INTR_MD_usb2_rx_ep_dataerr_intr_en_md_SHFT 16
#define SSUSB_EPCTL_CSR_USB2_RX_EP_DATAERR_INTR_MD_usb2_rx_ep_dataerr_intr_md_ADDR SSUSB_EPCTL_CSR_USB2_RX_EP_DATAERR_INTR_MD_ADDR
#define SSUSB_EPCTL_CSR_USB2_RX_EP_DATAERR_INTR_MD_usb2_rx_ep_dataerr_intr_md_MASK 0x0000FFFF                // usb2_rx_ep_dataerr_intr_md[15..0]
#define SSUSB_EPCTL_CSR_USB2_RX_EP_DATAERR_INTR_MD_usb2_rx_ep_dataerr_intr_md_SHFT 0

/* =====================================================================================

  ---EP_RST_OPT (0x74011800 + 0x090)---

    ep0_rst_opt[0]               - (RW) endpoint 0  reset option register
                                     1'b1:
                                     the 0x4 ep0_reset will reset :
                                     USB20 : data toggle
                                     SSUSB : sequence number, flow control status, packet pending status, ep active status, ep packet counter
                                     1'b0:
                                     the 0x4 ep0_reset will not reset others exclude data toggle and sequence number:
    ep_out_rst_opt[15..1]        - (RW) endpoint out 1 ~ 15 reset option register
                                     1'b1:
                                     the 0x4 ep_out_reset will reset :
                                     USB20 : data toggle
                                     SSUSB : sequence number, flow control status, packet pending status, ep active status, ep packet counter
                                     1'b0:
                                     the 0x4 ep_out_reset will not reset others exclude data toggle and sequence number:
    RESERVED16[16]               - (RO) Reserved bits
    ep_in_rst_opt[31..17]        - (RW) endpoint in 1 ~ 15 reset option register
                                     1'b1:
                                     the 0x4 ep_in_reset will reset :
                                     USB20 : data toggle
                                     SSUSB :  sequence number, flow control status, packet pending status, ep active status, ep packet counter
                                     1'b0:
                                     the 0x4 ep_in_reset will not reset others exclude data toggle and sequence number:

 =====================================================================================*/
#define SSUSB_EPCTL_CSR_EP_RST_OPT_ep_in_rst_opt_ADDR          SSUSB_EPCTL_CSR_EP_RST_OPT_ADDR
#define SSUSB_EPCTL_CSR_EP_RST_OPT_ep_in_rst_opt_MASK          0xFFFE0000                // ep_in_rst_opt[31..17]
#define SSUSB_EPCTL_CSR_EP_RST_OPT_ep_in_rst_opt_SHFT          17
#define SSUSB_EPCTL_CSR_EP_RST_OPT_ep_out_rst_opt_ADDR         SSUSB_EPCTL_CSR_EP_RST_OPT_ADDR
#define SSUSB_EPCTL_CSR_EP_RST_OPT_ep_out_rst_opt_MASK         0x0000FFFE                // ep_out_rst_opt[15..1]
#define SSUSB_EPCTL_CSR_EP_RST_OPT_ep_out_rst_opt_SHFT         1
#define SSUSB_EPCTL_CSR_EP_RST_OPT_ep0_rst_opt_ADDR            SSUSB_EPCTL_CSR_EP_RST_OPT_ADDR
#define SSUSB_EPCTL_CSR_EP_RST_OPT_ep0_rst_opt_MASK            0x00000001                // ep0_rst_opt[0]
#define SSUSB_EPCTL_CSR_EP_RST_OPT_ep0_rst_opt_SHFT            0

#ifdef __cplusplus
}
#endif

#endif // __SSUSB_EPCTL_CSR_REGS_H__
